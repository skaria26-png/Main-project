<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stock Price Predictor</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
    <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Helvetica Neue', Arial, 'Noto Sans', 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol', sans-serif; background: linear-gradient(135deg, #e6ebf4, #cfd8e6); min-height: 100vh; padding: 20px; color: #2c3e50; }
    .container { max-width: 1300px; margin: 0 auto; background: #fff; border-radius: 18px; box-shadow: 0 18px 40px rgba(0,0,0,0.08); overflow: hidden; border: 1px solid rgba(15,23,42,0.08); }
    .header { background: linear-gradient(135deg, #2c3e50, #3e4a5a); color: #fff; padding: 28px; text-align: center; border-bottom: 1px solid rgba(255,255,255,0.1); }
    .header h1 { font-weight: 600; letter-spacing: 0.3px; }
    .sub { opacity: 0.9; font-weight: 400; margin-top: 6px; }
    .content-grid { display: grid; grid-template-columns: 1fr 340px; }
    .primary { padding: 26px; }
    .sidebar { background: linear-gradient(180deg,#f7f9fc,#eef2f7); padding: 22px; border-left: 1px solid #e3e8f0; }
    .search-row { display: grid; gap: 12px; grid-template-columns: 1fr auto; align-items: center; }
    .search-input { width: 100%; padding: 14px 16px; border: 2px solid #e3e8f0; border-radius: 12px; outline: none; font-size: 15px; transition: box-shadow .2s, border-color .2s, background-color .2s; background-color: #fff; }
    .search-input:hover { border-color: #d7ddeb; }
    .search-input:focus { border-color: #5b7bd5; box-shadow: 0 0 0 4px rgba(91,123,213,0.12); background-color: #fbfdff; }
    .btn { padding: 12px 18px; border-radius: 10px; border: 1px solid rgba(15,23,42,0.08); background: linear-gradient(135deg,#5b7bd5,#6b8fe9); color: #fff; font-weight: 600; cursor: pointer; transition: transform .15s ease, box-shadow .15s ease, filter .15s ease; }
    .btn:hover { transform: translateY(-1px); box-shadow: 0 8px 18px rgba(91,123,213,0.22); filter: saturate(1.05); }
    .btn:active { transform: translateY(0); box-shadow: 0 4px 10px rgba(91,123,213,0.15); }
    .btn.secondary { background: #fff; color: #1f2937; border: 1px solid #e5e7eb; }
    .btn.secondary:hover { background: #f8fafc; }
    .timeframes { display: flex; gap: 10px; margin-top: 14px; flex-wrap: wrap; }
    .tf { padding: 8px 14px; border-radius: 9999px; border: 2px solid #e3e8f0; background: #fff; font-weight: 600; cursor: pointer; transition: background-color .2s, color .2s, border-color .2s, box-shadow .2s; }
    .tf:hover { border-color: #d7ddeb; box-shadow: 0 3px 10px rgba(0,0,0,0.04); }
    .tf.active { background: #5b7bd5; color: #fff; border-color: #5b7bd5; box-shadow: 0 6px 16px rgba(91,123,213,0.25); }
    .card { background: #fff; border-radius: 14px; padding: 18px; box-shadow: 0 8px 18px rgba(0,0,0,0.06); margin-top: 18px; border: 1px solid rgba(15,23,42,0.06); transition: box-shadow .2s, transform .2s; }
    .card:hover { box-shadow: 0 12px 24px rgba(0,0,0,0.08); transform: translateY(-1px); }
    .chart-card canvas { height: 260px; max-height: 260px; }
    .title { font-weight: 700; margin-bottom: 10px; }
    .grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(220px,1fr)); gap: 14px; }
    .info { background: #f8fafc; border-left: 4px solid #5b7bd5; border-radius: 10px; padding: 12px; text-align: center; border: 1px solid rgba(15,23,42,0.06); }
    .info .label { color: #6b7a90; font-size: 12px; text-transform: uppercase; letter-spacing: .3px; margin-bottom: 6px; }
    .info .value { font-size: 20px; font-weight: 700; }
    .kpis { display: grid; gap: 12px; }
    .kpi { display: flex; justify-content: space-between; align-items: center; background: #f3f6fb; border-left: 3px solid #5b7bd5; border-radius: 10px; padding: 12px; border: 1px solid rgba(15,23,42,0.06); }
    .muted { color: #6b7a90; }
    .bull { color: #1f9d57; font-weight: 700; }
    .bear { color: #d64545; font-weight: 700; }
    .notice { font-size: 13px; color: #6b7a90; line-height: 1.5; }
    @media (max-width: 920px) { .content-grid { grid-template-columns: 1fr; } .sidebar { border-left: none; border-top: 1px solid #e3e8f0; } }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
      <h1>Stock Price Predictor</h1>
      <div class="sub">NASDAQ-first real data, technicals, and 30-day outlook</div>
    </div>
    <div class="content-grid">
      <div class="primary">
        <div class="search-row">
          <input id="stockInput" class="search-input" placeholder="Type company or symbol (e.g., Apple or AAPL)" list="stockSuggestions">
          <datalist id="stockSuggestions"></datalist>
          <button class="btn" id="analyzeBtn">Analyze</button>
        </div>
        <div class="timeframes">
          <button class="tf active" data-days="7" data-range="7d">1W</button>
          <button class="tf" data-days="30" data-range="1mo">1M</button>
          <button class="tf" data-days="90" data-range="3mo">3M</button>
          <button class="tf" data-days="180" data-range="6mo">6M</button>
        </div>
        <div style="margin-top:10px; display:flex; gap:10px; align-items:center">
          <span class="muted" style="font-size:13px">Provider</span>
          <select id="providerSelect" class="search-input" style="max-width:220px; padding:8px 10px; height:auto">
            <option value="">Auto (Finnhub → Polygon → IEX → Alpha Vantage → Twelve Data → Yahoo)</option>
            <option value="finnhub">Finnhub (Real-time) [PRIMARY]</option>
            <option value="polygon">Polygon (Real-time)</option>
            <option value="iex">IEX Cloud (Real-time)</option>
            <option value="alpha_vantage">Alpha Vantage (Real-time)</option>
            <option value="twelve_data">Twelve Data (Real-time)</option>
            <option value="yahoo">Yahoo (Delayed)</option>
          </select>
        </div>

        <div class="card chart-card">
          <div class="title" id="histTitle">Historical Price</div>
          <canvas id="priceChart"></canvas>
            </div>

        <div class="card chart-card">
          <div class="title">Price Prediction</div>
          <div class="timeframes" style="margin-bottom:10px;">
            <button class="tf active" data-days="7" data-range="1w">1W</button>
            <button class="tf" data-days="21" data-range="3w">3W</button>
            <button class="tf" data-days="30" data-range="1m">1M</button>
            <button class="tf" data-days="90" data-range="3m">3M</button>
            <button class="tf" data-days="180" data-range="6m">6M</button>
          </div>
          <canvas id="predictionChart"></canvas>
            </div>

        <div class="card" id="results" style="display:none">
          <div class="grid" id="stockInfo"></div>
          <div style="margin-top:12px">
            <div id="predictionText" class="muted"></div>
          </div>
        </div>

        <div class="card" id="alphaVantageData" style="display:none">
          <div class="title">Alpha Vantage Analysis</div>
          <div id="technicalIndicators" style="margin-bottom:15px;">
            <div style="font-size:14px; font-weight:600; margin-bottom:8px;">Technical Indicators</div>
            <div id="indicatorsGrid" class="grid" style="grid-template-columns: repeat(auto-fit, minmax(150px,1fr));"></div>
          </div>
          <div id="companyOverview" style="margin-bottom:15px;">
            <div style="font-size:14px; font-weight:600; margin-bottom:8px;">Company Overview</div>
            <div id="overviewGrid" class="grid" style="grid-template-columns: repeat(auto-fit, minmax(200px,1fr));"></div>
          </div>
          <div style="text-align:center; margin-top:10px;">
            <button id="loadAlphaVantageBtn" class="btn" style="padding:8px 16px; font-size:12px;">Load Alpha Vantage Data</button>
          </div>
        </div>
                </div>
      <div class="sidebar">
        <div class="card">
          <div class="title">Quick KPIs</div>
          <div class="kpis">
            <div class="kpi"><span class="muted">Current Price</span><span id="kpiPrice">-</span></div>
            <div class="kpi"><span class="muted">Change</span><span id="kpiChange">-</span></div>
            <div class="kpi"><span class="muted">Volume</span><span id="kpiVolume">-</span></div>
            <div class="kpi"><span class="muted">Market Cap</span><span id="kpiMcap">-</span></div>
            <div class="kpi"><span class="muted">P/E</span><span id="kpiPE">-</span></div>
            <div class="kpi"><span class="muted">Prev Close</span><span id="kpiPrev">-</span></div>
            <div class="kpi"><span class="muted">Day High</span><span id="kpiHigh">-</span></div>
            <div class="kpi"><span class="muted">Day Low</span><span id="kpiLow">-</span></div>
          </div>
                    </div>
        <div class="card">
          <div class="title">Market Mood</div>
          <div style="text-align:center">
            <canvas id="moodChart" style="max-width:200px; max-height:200px"></canvas>
            <div style="display:flex; justify-content:space-around; margin-top:10px">
              <div><div id="bullPct" class="bull">0%</div><div class="muted" style="font-size:12px">Bullish</div></div>
              <div><div id="bearPct" class="bear">0%</div><div class="muted" style="font-size:12px">Bearish</div></div>
                        </div>
                    </div>
                </div>
        <div class="card">
          <div class="title">Data Comparison</div>
          <div id="dataComparison" style="font-size:12px; color:#666;">
            <div>Click "Test All Providers" to see why prices differ</div>
          </div>
          <button id="testProvidersBtn" class="btn" style="margin-top:10px; padding:8px 12px; font-size:12px;">Test All Providers</button>
                    </div>
        <div class="card">
          <div class="title">Data Sources</div>
          <div class="notice">
            <strong>Primary:</strong> <a href="https://finnhub.io/" target="_blank" style="color:#5b7bd5;">Finnhub.io</a> (Real-time)<br>
            <strong>Enhanced:</strong> <a href="https://www.alphavantage.co/" target="_blank" style="color:#5b7bd5;">Alpha Vantage</a> (Real-time + Technicals)<br>
            <strong>Free API Keys:</strong><br>
            • Finnhub: <code>FINNHUB_API_KEY=your_key</code><br>
            • Alpha Vantage: <code>ALPHA_VANTAGE_KEY=your_key</code><br>
            <strong>Alpha Vantage Features:</strong><br>
            • Real-time quotes & historical data<br>
            • Technical indicators (RSI, MACD, Bollinger Bands)<br>
            • Company overview & fundamentals<br>
            • 20+ years of historical data
          </div>
        </div>
        <div class="card">
          <div class="title">Important Notice</div>
          <div class="notice">This tool uses public market data for educational purposes and is not financial advice.</div>
                </div>
            </div>
        </div>
    </div>

    <script>
    const stockDataCache = { quotes: new Map(), history: new Map(), suggestions: new Map() };
    const CACHE_DURATION = 1000 * 60 * 5; // 5 minutes

    // Built-in popular companies for instant lookup (prioritize NASDAQ, then NYSE)
    const localCompanies = [
      { s: 'AAPL', n: 'Apple Inc.', e: 'NASDAQ' },
      { s: 'MSFT', n: 'Microsoft Corporation', e: 'NASDAQ' },
      { s: 'NVDA', n: 'NVIDIA Corporation', e: 'NASDAQ' },
      { s: 'TSLA', n: 'Tesla, Inc.', e: 'NASDAQ' },
      { s: 'AMZN', n: 'Amazon.com, Inc.', e: 'NASDAQ' },
      { s: 'GOOGL', n: 'Alphabet Inc. Class A', e: 'NASDAQ' },
      { s: 'GOOG', n: 'Alphabet Inc. Class C', e: 'NASDAQ' },
      { s: 'META', n: 'Meta Platforms, Inc.', e: 'NASDAQ' },
      { s: 'NFLX', n: 'Netflix, Inc.', e: 'NASDAQ' },
      { s: 'AVGO', n: 'Broadcom Inc.', e: 'NASDAQ' },
      { s: 'AMD', n: 'Advanced Micro Devices, Inc.', e: 'NASDAQ' },
      { s: 'INTC', n: 'Intel Corporation', e: 'NASDAQ' },
      { s: 'QCOM', n: 'QUALCOMM Incorporated', e: 'NASDAQ' },
      { s: 'ADI', n: 'Analog Devices, Inc.', e: 'NASDAQ' },
      { s: 'MU', n: 'Micron Technology, Inc.', e: 'NASDAQ' },
      { s: 'CRWD', n: 'CrowdStrike Holdings, Inc.', e: 'NASDAQ' },
      { s: 'PANW', n: 'Palo Alto Networks, Inc.', e: 'NASDAQ' },
      { s: 'SNOW', n: 'Snowflake Inc.', e: 'NYSE' },
      { s: 'SHOP', n: 'Shopify Inc.', e: 'NYSE' },
      { s: 'ABNB', n: 'Airbnb, Inc.', e: 'NASDAQ' },
      { s: 'UBER', n: 'Uber Technologies, Inc.', e: 'NYSE' },
      { s: 'LYFT', n: 'Lyft, Inc.', e: 'NASDAQ' },
      { s: 'ORCL', n: 'Oracle Corporation', e: 'NYSE' },
      { s: 'JPM', n: 'JPMorgan Chase & Co.', e: 'NYSE' },
      { s: 'BAC', n: 'Bank of America Corporation', e: 'NYSE' },
      { s: 'WFC', n: 'Wells Fargo & Company', e: 'NYSE' },
      { s: 'V', n: 'Visa Inc.', e: 'NYSE' },
      { s: 'MA', n: 'Mastercard Incorporated', e: 'NYSE' },
      { s: 'KO', n: 'The Coca-Cola Company', e: 'NYSE' },
      { s: 'PEP', n: 'PepsiCo, Inc.', e: 'NASDAQ' },
      { s: 'MCD', n: 'McDonald\'s Corporation', e: 'NYSE' },
      { s: 'DIS', n: 'The Walt Disney Company', e: 'NYSE' },
      { s: 'NKE', n: 'NIKE, Inc.', e: 'NYSE' },
      { s: 'T', n: 'AT&T Inc.', e: 'NYSE' },
      { s: 'VZ', n: 'Verizon Communications Inc.', e: 'NYSE' },
      { s: 'XOM', n: 'Exxon Mobil Corporation', e: 'NYSE' },
      { s: 'CVX', n: 'Chevron Corporation', e: 'NYSE' },
      { s: 'PFE', n: 'Pfizer Inc.', e: 'NYSE' },
      { s: 'JNJ', n: 'Johnson & Johnson', e: 'NYSE' },
      { s: 'MRK', n: 'Merck & Co., Inc.', e: 'NYSE' },
      { s: 'UNH', n: 'UnitedHealth Group Incorporated', e: 'NYSE' },
      { s: 'LLY', n: 'Eli Lilly and Company', e: 'NYSE' },
      { s: 'COST', n: 'Costco Wholesale Corporation', e: 'NASDAQ' },
      { s: 'HD', n: 'The Home Depot, Inc.', e: 'NYSE' },
      { s: 'LOW', n: 'Lowe\'s Companies, Inc.', e: 'NYSE' },
      { s: 'TSM', n: 'Taiwan Semiconductor Manufacturing Company Limited', e: 'NYSE' },
      { s: 'BABA', n: 'Alibaba Group Holding Limited', e: 'NYSE' },
      { s: 'SONY', n: 'Sony Group Corporation', e: 'NYSE' },
      { s: 'PLTR', n: 'Palantir Technologies Inc.', e: 'NYSE' },
      { s: 'SQ', n: 'Block, Inc.', e: 'NYSE' },
      { s: 'PYPL', n: 'PayPal Holdings, Inc.', e: 'NASDAQ' },
      { s: 'IBM', n: 'International Business Machines Corporation', e: 'NYSE' },
      { s: 'CRM', n: 'Salesforce, Inc.', e: 'NYSE' },
      { s: 'ADBE', n: 'Adobe Inc.', e: 'NASDAQ' },
      { s: 'INTU', n: 'Intuit Inc.', e: 'NASDAQ' },
      { s: 'SPOT', n: 'Spotify Technology S.A.', e: 'NYSE' },
      { s: 'NET', n: 'Cloudflare, Inc.', e: 'NYSE' },
      { s: 'ZM', n: 'Zoom Video Communications, Inc.', e: 'NASDAQ' },
      { s: 'DOCU', n: 'DocuSign, Inc.', e: 'NASDAQ' },
      { s: 'ETSY', n: 'Etsy, Inc.', e: 'NASDAQ' },
      { s: 'ROKU', n: 'Roku, Inc.', e: 'NASDAQ' },
      { s: 'F', n: 'Ford Motor Company', e: 'NYSE' },
      { s: 'GM', n: 'General Motors Company', e: 'NYSE' }
    ];

    let currentSymbol = null;
    let currentExchange = null;
    let selectedRange = '7d';
    let selectedDays = 7;
    let selectedPredictionDays = 30;
    let priceChart = null;
    let predictionChart = null;
    let moodChart = null;
    let liveTimer = null;

    const sleep = (ms) => new Promise(r => setTimeout(r, ms));

    function formatCurrency(n, c = 'USD') {
      if (n == null || isNaN(n)) return '-';
      try { return new Intl.NumberFormat('en-US', { style: 'currency', currency: c, maximumFractionDigits: 2 }).format(n); } catch { return `$${Number(n).toFixed(2)}`; }
    }
    function formatNumber(n) { return n == null ? '-' : new Intl.NumberFormat('en-US').format(n); }
    function formatMcap(n) { if (n == null) return '-'; if (n >= 1e12) return `${(n/1e12).toFixed(2)}T`; if (n >= 1e9) return `${(n/1e9).toFixed(2)}B`; if (n >= 1e6) return `${(n/1e6).toFixed(2)}M`; return formatNumber(n); }

    // Deterministic RNG and fallbacks (ensures graphs even when offline)
    function createSeededRng(seed) {
      let state = 0;
      for (let i = 0; i < seed.length; i++) state = (state * 31 + seed.charCodeAt(i)) >>> 0;
      return function() { state = (1103515245 * state + 12345) % 0x80000000; return state / 0x80000000; };
    }

    function generateFallbackQuote(symbol) {
      const rng = createSeededRng(symbol);
      const base = 50 + Math.floor(rng() * 400);
      const change = (rng() - 0.5) * 5;
      const price = Math.max(5, base + change);
      return {
        provider: 'fallback',
        symbol,
        name: (localCompanies.find(c => c.s === symbol)?.n) || symbol,
        price,
        change,
        changePercent: (change / (price - change)) * 100,
        volume: Math.floor(5_000_000 + rng() * 50_000_000),
        marketCap: Math.floor(price * (200_000_000 + rng() * 2_000_000_000)),
        pe: Math.round(10 + rng() * 35),
        previousClose: price - change,
        dayHigh: price + Math.abs(change) * 1.4,
        dayLow: price - Math.abs(change) * 1.4,
        currency: 'USD',
        exchangeName: (localCompanies.find(c => c.s === symbol)?.e) || '—'
      };
    }

    function daysForRange(range) {
      if (range === '7d') return 7; if (range === '1mo') return 30; if (range === '3mo') return 90; if (range === '6mo') return 180; return 60;
    }

    function generateFallbackHistory(symbol, range) {
      const n = daysForRange(range);
      const rng = createSeededRng(symbol + 'hist' + range);
      const baseQuote = generateFallbackQuote(symbol);
      const base = baseQuote.price;
      const out = [];
      let p = base;
      for (let i = n - 1; i >= 0; i--) {
        const drift = (rng() - 0.5) * 0.01; // gentle drift
        const season = Math.sin((n - i) / 8) * 0.008;
        const vol = (rng() - 0.5) * 0.02;
        p = Math.max(3, p * (1 + drift + season + vol));
        out.push({ date: new Date(Date.now() - i * 86400000), price: p });
      }
      return out;
    }

    async function resolveSymbolFromApi(query) {
      const key = query.toLowerCase();
      const now = Date.now();
      const cached = stockDataCache.suggestions.get(key);
      if (cached && now - cached.t < CACHE_DURATION) return cached.v;

      const url = `https://query2.finance.yahoo.com/v1/finance/search?q=${encodeURIComponent(query)}&quotesCount=10&newsCount=0`;
      const res = await fetch(url);
      if (!res.ok) throw new Error('Search failed');
      const data = await res.json();
      const quotes = (data.quotes || []).filter(q => q.quoteType === 'EQUITY');
      const nasdaq = quotes.filter(q => q.exchDisp === 'NASDAQ' || q.exchange === 'NMS');
      const nyse = quotes.filter(q => q.exchDisp === 'NYSE' || q.exchange === 'NYQ');
      const ordered = [...nasdaq, ...nyse, ...quotes];
      stockDataCache.suggestions.set(key, { t: now, v: ordered });
      return ordered;
    }

    // Backend first helpers
    async function backendFetchQuote(symbol) {
      const prov = document.getElementById('providerSelect')?.value || '';
      const res = await fetch(`/api/quote?symbol=${encodeURIComponent(symbol)}${prov?`&provider=${prov}`:''}`);
      if (!res.ok) throw new Error('backend quote failed');
      return await res.json();
    }
    async function backendFetchHistory(symbol, range) {
      const prov = document.getElementById('providerSelect')?.value || '';
      const res = await fetch(`/api/history?symbol=${encodeURIComponent(symbol)}&range=${encodeURIComponent(range)}${prov?`&provider=${prov}`:''}`);
      if (!res.ok) throw new Error('backend history failed');
      return await res.json();
    }

    async function updateSuggestions(e) {
      const val = e.target.value.trim();
      const dl = document.getElementById('stockSuggestions');
      if (!val) { dl.innerHTML = ''; populateInitialDatalist(); return; }
      let merged = [];
      try {
        const results = await resolveSymbolFromApi(val);
        merged = results.map(q => ({ s: q.symbol, n: q.longname || q.shortname || q.symbol, e: q.exchDisp || q.exchange || '' }));
      } catch {
        merged = [];
      }
      const localMatches = localCompanies.filter(c => c.s.startsWith(val.toUpperCase()) || c.n.toLowerCase().includes(val.toLowerCase()));
      merged = [...localMatches, ...merged];
      // Dedupe by symbol
      const seen = new Set();
      const deduped = [];
      for (const item of merged) { if (!seen.has(item.s)) { seen.add(item.s); deduped.push(item); } }

      dl.innerHTML = '';
      deduped.slice(0, 20).forEach(q => {
        const opt = document.createElement('option');
        opt.value = q.s;
        opt.label = `${q.n} (${q.e || '—'})`;
        dl.appendChild(opt);
      });
    }

    async function fetchLiveQuote(symbol) {
      const now = Date.now();
      const key = symbol.toUpperCase();
      const cached = stockDataCache.quotes.get(key);
      if (cached && now - cached.t < 30_000) return cached.v; // 30s for quotes

      const url = `https://query1.finance.yahoo.com/v7/finance/quote?symbols=${encodeURIComponent(symbol)}`;
      const res = await fetch(url);
      if (!res.ok) throw new Error('Quote failed');
      const data = await res.json();
      const q = (data.quoteResponse?.result || [])[0];
      if (!q) throw new Error('No quote');
      const marketState = q.marketState; // PRE, REGULAR, POST, CLOSED, etc.
      const pre = q.preMarketPrice;
      const post = q.postMarketPrice;
      const regular = q.regularMarketPrice;
      let displayPrice = regular;
      let session = 'REGULAR';
      if ((marketState === 'PRE' || marketState === 'PREPRE') && pre != null) { displayPrice = pre; session = 'PRE'; }
      else if ((marketState === 'POST' || marketState === 'POSTPOST' || marketState === 'CLOSED') && post != null) { displayPrice = post; session = 'POST'; }
      const asOfEpoch = (session === 'PRE' ? q.preMarketTime : (session === 'POST' ? q.postMarketTime : q.regularMarketTime));
      const asOf = asOfEpoch ? new Date(asOfEpoch * 1000) : new Date();

      const value = {
        provider: 'yahoo',
        symbol: q.symbol,
        name: q.longName || q.shortName || q.symbol,
        price: displayPrice,
        change: q.regularMarketChange, // session change fields vary; keep regular change for reference
        changePercent: q.regularMarketChangePercent,
        volume: q.regularMarketVolume,
        marketCap: q.marketCap,
        pe: q.trailingPE,
        previousClose: q.regularMarketPreviousClose ?? q.previousClose,
        dayHigh: q.regularMarketDayHigh ?? q.dayHigh,
        dayLow: q.regularMarketDayLow ?? q.dayLow,
        currency: q.currency || 'USD',
        exchangeName: q.fullExchangeName || q.exchange || q.exchangeDisplay || '—',
        marketState: marketState || '—',
        session,
        asOfISO: asOf.toISOString(),
        isDelayed: true
      };
      stockDataCache.quotes.set(key, { t: now, v: value });
      return value;
    }

    async function fetchStockHistory(symbol, range) {
      const key = `${symbol}|${range}`;
      const now = Date.now();
      const cached = stockDataCache.history.get(key);
      if (cached && now - cached.t < CACHE_DURATION) return cached.v;

      const url = `https://query1.finance.yahoo.com/v8/finance/chart/${encodeURIComponent(symbol)}?range=${encodeURIComponent(range)}&interval=1d&events=div,splits`;
      const res = await fetch(url);
      if (!res.ok) throw new Error('History failed');
      const json = await res.json();
      const result = json.chart?.result?.[0];
      if (!result) throw new Error('No history');
      const ts = result.timestamp || [];
      const quote = result.indicators?.quote?.[0] || {};
      const closes = quote.close || [];
      const out = [];
      for (let i = 0; i < ts.length; i++) {
        const c = closes[i];
        if (c == null) continue;
        out.push({ date: new Date(ts[i] * 1000), price: c });
      }
      if (out.length === 0) throw new Error('Empty history');
      stockDataCache.history.set(key, { t: now, v: out });
      return out;
    }

    // Safe wrappers with backend -> yahoo -> fallback
    async function safeFetchLiveQuote(symbol) {
      try { return await backendFetchQuote(symbol); } catch {}
      try { return await fetchLiveQuote(symbol); } catch { return generateFallbackQuote(symbol); }
    }
    async function safeFetchStockHistory(symbol, range) {
      try { return await backendFetchHistory(symbol, range); } catch {}
      try { return await fetchStockHistory(symbol, range); } catch { return generateFallbackHistory(symbol, range); }
    }

    function calculateEMA(values, period) {
      if (values.length === 0) return 0;
      const k = 2 / (period + 1);
      let ema = values[0];
      for (let i = 1; i < values.length; i++) ema = values[i] * k + ema * (1 - k);
            return ema;
        }
    function calculateSMA(values, period) {
      if (values.length < period) return values[values.length - 1] ?? 0;
      const slice = values.slice(-period);
      const sum = slice.reduce((a, b) => a + b, 0);
            return sum / period;
        }
    function calculateRSI(values, period = 14) {
      if (values.length < period + 1) return 50;
      let gains = 0, losses = 0;
      for (let i = values.length - period; i < values.length; i++) {
        const diff = values[i] - values[i - 1];
        if (diff > 0) gains += diff; else losses -= diff;
      }
      const avgGain = gains / period, avgLoss = losses / period;
      if (avgLoss === 0) return 100;
      const rs = avgGain / avgLoss;
      return 100 - 100 / (1 + rs);
    }
    function calculateMACD(values) {
      if (values.length < 40) return { macd: 0, signal: 0, histogram: 0 };
      const ema12 = calculateEMA(values, 20);
      const ema26 = calculateEMA(values, 40);
      const macd = ema12 - ema26;
      const signal = macd * 0.9; // simplified
      return { macd, signal, histogram: macd - signal };
    }
    function calculateVolatility(values) {
      if (values.length < 2) return 0;
      const rets = [];
      for (let i = 1; i < values.length; i++) rets.push((values[i] - values[i-1]) / values[i-1]);
      const mean = rets.reduce((a,b)=>a+b,0)/rets.length;
      const varc = rets.reduce((a,r)=>a+Math.pow(r-mean,2),0)/rets.length;
      return Math.sqrt(varc);
    }

    // Professional technical indicators used by institutional traders
    function calculateBollingerBands(prices, period = 20, stdDev = 2) {
      if (prices.length < period) return { upper: 0, middle: 0, lower: 0 };
      const sma = calculateSMA(prices, period);
      const slice = prices.slice(-period);
      const variance = slice.reduce((acc, price) => acc + Math.pow(price - sma, 2), 0) / period;
      const std = Math.sqrt(variance);
      return {
        upper: sma + (stdDev * std),
        middle: sma,
        lower: sma - (stdDev * std)
      };
    }

    function calculateStochastic(prices, kPeriod = 14, dPeriod = 3) {
      if (prices.length < kPeriod) return { k: 50, d: 50 };
      const slice = prices.slice(-kPeriod);
      const high = Math.max(...slice);
      const low = Math.min(...slice);
      const current = prices[prices.length - 1];
      const k = ((current - low) / (high - low)) * 100;
      
      // Simple D calculation (3-period SMA of K)
      const kValues = [];
      for (let i = kPeriod - 1; i < prices.length; i++) {
        const periodSlice = prices.slice(i - kPeriod + 1, i + 1);
        const periodHigh = Math.max(...periodSlice);
        const periodLow = Math.min(...periodSlice);
        const periodK = ((prices[i] - periodLow) / (periodHigh - periodLow)) * 100;
        kValues.push(periodK);
      }
      const d = calculateSMA(kValues, dPeriod);
      return { k, d };
    }

    function calculateWilliamsR(prices, period = 14) {
      if (prices.length < period) return 0;
      const slice = prices.slice(-period);
      const high = Math.max(...slice);
      const low = Math.min(...slice);
      const current = prices[prices.length - 1];
      return ((high - current) / (high - low)) * -100;
    }

    function calculateATR(prices, period = 14) {
      if (prices.length < period + 1) return 0;
      const trueRanges = [];
      for (let i = 1; i < prices.length; i++) {
        const high = prices[i];
        const low = prices[i - 1];
        const prevClose = prices[i - 1];
        const tr = Math.max(high - low, Math.abs(high - prevClose), Math.abs(low - prevClose));
        trueRanges.push(tr);
      }
      return calculateSMA(trueRanges.slice(-period), period);
    }

    function generatePrediction(quote, history) {
      const prices = history.map(d => d.price);
            const rsi = calculateRSI(prices);
            const macd = calculateMACD(prices);
      const sma20 = calculateSMA(prices, 20);
      const sma50 = calculateSMA(prices, 50);
      const sma5 = calculateSMA(prices, 5);
      const sma10 = calculateSMA(prices, 10);
      const current = prices[prices.length - 1];

      // Professional indicators
      const bb = calculateBollingerBands(prices);
      const stoch = calculateStochastic(prices);
      const williamsR = calculateWilliamsR(prices);
      const atr = calculateATR(prices);

      let bull = 0, bear = 0;

      // RSI Analysis (Professional levels)
      if (rsi < 25) bull += 3; // Oversold
      else if (rsi > 75) bear += 3; // Overbought
      else if (rsi < 40) bull += 1; // Weak oversold
      else if (rsi > 60) bear += 1; // Weak overbought
      else if (rsi > 50) bull += 0.5; // Slight bullish
      else bear += 0.5; // Slight bearish

      // MACD Analysis
      if (macd.macd > macd.signal) bull += 1; else bear += 1;
      if (macd.histogram > 0) bull += 0.5; else bear += 0.5;

      // Moving Average Analysis (Professional)
      if (current > sma20 && sma20 > sma50) bull += 2; // Uptrend
      else if (current < sma20 && sma20 < sma50) bear += 2; // Downtrend
      else if (current > sma20) bull += 1; // Above short-term MA
      else bear += 1; // Below short-term MA

      // Short-term momentum
      if (sma5 > sma10) bull += 1; else bear += 1;

      // Bollinger Bands Analysis
      if (current < bb.lower) bull += 2; // Oversold bounce
      else if (current > bb.upper) bear += 2; // Overbought rejection
      else if (current > bb.middle) bull += 0.5; // Above middle
      else bear += 0.5; // Below middle

      // Stochastic Analysis
      if (stoch.k < 20 && stoch.d < 20) bull += 1; // Oversold
      else if (stoch.k > 80 && stoch.d > 80) bear += 1; // Overbought
      else if (stoch.k > stoch.d) bull += 0.5; // K above D
      else bear += 0.5; // K below D

      // Williams %R Analysis
      if (williamsR < -80) bull += 1; // Oversold
      else if (williamsR > -20) bear += 1; // Overbought

      // Volume Analysis (Professional)
      if (quote.volume) {
        const avgVolume = 30_000_000; // Average volume assumption
        const volumeRatio = quote.volume / avgVolume;
        if (volumeRatio > 2) { // High volume
          if (current > prices[prices.length-2]) bull += 1.5; // Volume confirmation
          else bear += 1.5;
        } else if (volumeRatio > 1.5) {
          if (current > prices[prices.length-2]) bull += 0.5;
          else bear += 0.5;
        }
      }

      // Price Momentum (Professional)
      if (prices.length >= 10) {
        const shortMomentum = (current - prices[prices.length-5]) / prices[prices.length-5];
        const longMomentum = (current - prices[prices.length-10]) / prices[prices.length-10];
        
        if (shortMomentum > 0.03) bull += 1; // Strong short-term momentum
        else if (shortMomentum < -0.03) bear += 1;
        
        if (longMomentum > 0.05) bull += 1; // Strong long-term momentum
        else if (longMomentum < -0.05) bear += 1;
      }

      // Volatility Analysis (Professional)
      const vol = calculateVolatility(prices);
      if (vol > 0.05) { // High volatility - reduce confidence
        bull *= 0.8;
        bear *= 0.8;
      } else if (vol < 0.01) { // Low volatility - normal confidence
        bull *= 1.1;
        bear *= 1.1;
      }

      // ATR Analysis
      if (atr > 0) {
        const atrRatio = atr / current;
        if (atrRatio > 0.03) { // High volatility
          bull *= 0.9;
          bear *= 0.9;
        }
      }

      // Fundamental Analysis (Professional)
      if (quote.pe) {
        if (quote.pe < 15) bull += 1; // Undervalued
        else if (quote.pe > 30) bear += 1; // Overvalued
        else if (quote.pe < 25) bull += 0.5; // Reasonable valuation
        else bear += 0.5; // Expensive
      }

      // Market Cap Analysis
      if (quote.marketCap) {
        if (quote.marketCap > 1e12) { // Large cap - more stable
          bull *= 1.1;
          bear *= 1.1;
        } else if (quote.marketCap < 1e9) { // Small cap - more volatile
          bull *= 0.9;
          bear *= 0.9;
        }
      }

      const total = bull + bear;
      const ratio = total > 0 ? bull / total : 0.5;
      const direction = ratio > 0.5 ? 'bullish' : 'bearish';
      const confidence = Math.round(Math.min(Math.abs(ratio - 0.5) * 2, 0.95) * 100);
            
            return {
        direction, 
        confidence, 
        bullishRatio: ratio,
        indicators: {
          rsi, macd, sma20, sma50, bb, stoch, williamsR, atr, volatility: vol
        }
      };
    }

    // Simple linear regression slope of last N prices (normalized by price)
    function linearRegressionSlope(values, window = 20) {
      if (!values || values.length < 2) return 0;
      const n = Math.min(window, values.length);
      const slice = values.slice(-n);
      const meanX = (n - 1) / 2;
      const meanY = slice.reduce((a,b)=>a+b,0) / n;
      let num = 0, den = 0;
      for (let i = 0; i < n; i++) { num += (i - meanX) * (slice[i] - meanY); den += (i - meanX) * (i - meanX); }
      const slope = den === 0 ? 0 : num / den; // price change per step
      const last = slice[slice.length - 1] || 1;
      return last ? slope / last : 0; // normalize to percent per step
    }

    function generatePredictionPath(quote, history, days = selectedPredictionDays) {
      // Recompute indicator-driven signal so direction is correct and stock-specific
      const prices = history.map(d => d.price);
      const last = prices[prices.length - 1];
      const live = Number(quote?.price) > 0 ? Number(quote.price) : last;
      const rsi = calculateRSI(prices, 14);
      const macd = calculateMACD(prices); // { macd, signal, histogram }
      const sma20 = calculateSMA(prices, 20);
      const sma50 = calculateSMA(prices, 50);
      const bb = calculateBollingerBands(prices, 20, 2);
      const vol = Math.max(0.001, Math.min(0.12, calculateVolatility(prices)));
      const slope = linearRegressionSlope(prices, 20); // normalized per step

      // Build a composite signal in [-1, 1]
      let signal = 0;
      // RSI distance from neutral (50)
      signal += ((rsi - 50) / 50) * 0.35;
      // MACD histogram sign and strength (bounded)
      const macdStrength = Math.max(-1, Math.min(1, (macd.histogram || 0) / Math.max(1e-6, Math.abs(macd.signal) + 1e-6)));
      signal += macdStrength * 0.25;
      // Trend from MA alignment and gap
      const maGap = (sma20 && sma50) ? (sma20 - sma50) / Math.max(1e-6, sma50) : 0;
      signal += Math.max(-0.4, Math.min(0.4, maGap)) * 0.25;
      // Price vs BB middle
      const bbMiddle = bb.middle || sma20 || last;
      const midGap = (last - bbMiddle) / Math.max(1e-6, bbMiddle);
      signal += Math.max(-0.3, Math.min(0.3, midGap)) * 0.15;
      // Recent momentum (slope)
      signal += Math.max(-0.4, Math.min(0.4, slope * 15)) * 0.2;

      // Clamp signal
      signal = Math.max(-1, Math.min(1, signal));

      // Confidence increases when indicators agree and volatility is moderate
      const agreement = (
        (rsi > 55 ? 1 : rsi < 45 ? 1 : 0) +
        (macd.histogram > 0 ? 1 : macd.histogram < 0 ? 1 : 0) +
        (sma20 > sma50 ? 1 : sma20 < sma50 ? 1 : 0) +
        (last > bbMiddle ? 1 : last < bbMiddle ? 1 : 0)
      ) / 4;
      const baseConf = 0.5 + 0.4 * Math.abs(signal) * (0.6 + 0.4 * agreement);
      const conf = Math.max(0.3, Math.min(0.95, baseConf * (1 - Math.min(vol * 6, 0.5))));

      // Symbol-specific bias to avoid identical shapes across symbols
      const symbolKey = `${quote.symbol || 'SYM'}|${quote.exchangeName || ''}`;
      const rng = createSeededRng(symbolKey);
      const symbolBias = (rng() - 0.5) * 0.001; // keep tilt tiny to avoid upward bias

      // Recent return statistics to anchor 30-day drift uniquely per stock
      const rets = [];
      for (let i = 1; i < prices.length; i++) {
        const prev = prices[i-1]; const curr = prices[i];
        if (prev > 0 && curr > 0) rets.push((curr - prev) / prev);
      }
      const retMean = rets.length ? rets.reduce((a,b)=>a+b,0)/rets.length : 0;
      const retStd = rets.length ? Math.sqrt(rets.reduce((a,r)=>a+(r-retMean)*(r-retMean),0)/rets.length) : vol;

      // ECONOMETRIC core: blend realized mean return, indicator signal, and regime filters
      // 1) Momentum vs mean-reversion signals
      const isDownRegime = (slope < 0) && (macd.histogram < 0) && (sma20 < sma50) && (last < bbMiddle);
      const isUpRegime   = (slope > 0) && (macd.histogram > 0) && (sma20 > sma50) && (last > bbMiddle);
      // 2) Overbought/oversold mean-reversion pressure
      const overbought = (rsi > 65) || (last > (bb.upper || Infinity));
      const oversold   = (rsi < 35) || (last < (bb.lower || 0));

      // Baseline drift from realized mean (arith approx of daily log-mean)
      const muArith = retMean; // small returns ~ arithmetic
      let driftPerDay = (
        muArith * 0.6
        + signal * 0.0045 * (0.5 + 0.8 * conf)
        + symbolBias
      ) * (1 - Math.min(vol * 7, 0.55));

      // Regime gating: disallow positive drift in confirmed downtrend; vice versa for strong uptrend allow more
      if (isDownRegime && driftPerDay > 0) driftPerDay = Math.min(driftPerDay, 0.0002);
      if (isUpRegime) driftPerDay = driftPerDay + Math.abs(driftPerDay) * 0.2;

      // Stronger mean reversion at extremes
      if (overbought) driftPerDay -= 0.003 * (0.5 + conf); // push down when overbought
      if (oversold)   driftPerDay += 0.003 * (0.5 + conf); // push up when oversold

      // Noise model proportional to volatility, gently decays across horizon
      const baseNoise = Math.min(0.014, 0.35 * Math.max(vol, retStd)); // cap noise amplitude

      const out = [];
      // Start path from the live price so predictions visually align with real-time
      let price = live;
      for (let i = 1; i <= days; i++) {
        const t = i / days; // 0..1
        const easing = 0.35 * t + 0.65 * t * t; // smoother build-up
        // symbol-phased seasonal components -> distinct shapes per symbol
        const phase1 = (rng() * Math.PI * 2);
        const phase2 = (rng() * Math.PI * 2);
        const seasonal = Math.sin(i / 6 + phase1) * 0.0018 + Math.sin(i / 13 + phase2) * 0.0011;
        // Skew noise slightly with regime: more downside wiggle in downtrends
        const rand = (rng() - 0.5) * 2;
        const skew = isDownRegime ? -0.3 : (isUpRegime ? 0.15 : 0);
        const noise = (rand + skew) * baseNoise * (1 - 0.45 * t);
        const dailyReturn = driftPerDay * easing + seasonal + noise;
        price = Math.max(live * 0.7, price * (1 + dailyReturn));
        out.push({ date: new Date(Date.now() + i * 86400000), price });
      }

      // Provide an updated prediction summary consistent with our signal
      // Determine direction vs live price to avoid mismatches
      const direction = out[out.length - 1].price >= live ? 'bullish' : 'bearish';
      const pred = {
        direction,
        // Sharpe-like boost/damp of confidence based on in-sample mean/vol
        confidence: Math.round(
          Math.min(0.95, Math.max(0.25, conf * (1 + Math.min(0.5, (retMean / (retStd + 1e-6)) )))) * 100
        ),
        bullishRatio: Math.max(0, Math.min(1, 0.5 + signal * 0.5)),
        indicators: { rsi, macd, sma20, sma50, bb, volatility: vol }
      };

      return { pred, data: out };
    }

    function drawPriceChart(history) {
      const ctx = document.getElementById('priceChart').getContext('2d');
      if (priceChart) priceChart.destroy();
      priceChart = new Chart(ctx, {
        type: 'line',
        data: { labels: history.map(d => d.date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' })), datasets: [{ label: 'Price', data: history.map(d => d.price), borderColor: '#5b7bd5', backgroundColor: 'rgba(91,123,213,0.12)', fill: true, borderWidth: 2, tension: 0.35, pointRadius: 0 }] },
        options: { responsive: true, maintainAspectRatio: false, plugins: { legend: { display: false } }, scales: { x: { display: true, grid: { color: 'rgba(0,0,0,0.05)' } }, y: { beginAtZero: false, grid: { color: 'rgba(0,0,0,0.08)' } } }, interaction: { intersect: false, mode: 'index' } }
      });
    }

    function drawPredictionChart(path, pred) {
      const ctx = document.getElementById('predictionChart').getContext('2d');
      if (predictionChart) predictionChart.destroy();
      const isBullish = pred?.direction === 'bullish' || (path?.length ? path[path.length-1].price > path[0].price : false);
      const lineColor = isBullish ? '#1f9d57' : '#d64545';
      const fillColor = isBullish ? 'rgba(31,157,87,0.10)' : 'rgba(214,69,69,0.10)';
      predictionChart = new Chart(ctx, {
        type: 'line',
        data: { labels: path.map(d => d.date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' })), datasets: [{ label: 'Predicted', data: path.map(d => d.price), borderColor: lineColor, backgroundColor: fillColor, fill: true, borderWidth: 2, tension: 0.35, pointRadius: 0, borderDash: [5,4] }] },
        options: { responsive: true, maintainAspectRatio: false, plugins: { legend: { display: false } }, scales: { x: { display: true, grid: { color: 'rgba(0,0,0,0.05)' } }, y: { beginAtZero: false, grid: { color: 'rgba(0,0,0,0.08)' } } }, interaction: { intersect: false, mode: 'index' } }
      });
    }

    function updateMoodChart(pred) {
      const ctx = document.getElementById('moodChart').getContext('2d');
      if (moodChart) moodChart.destroy();
      const bull = Math.round(pred.bullishRatio * 100);
      const bear = 100 - bull;
      moodChart = new Chart(ctx, { type: 'doughnut', data: { labels: ['Bullish','Bearish'], datasets: [{ data: [bull, bear], backgroundColor: ['#1f9d57','#d64545'], borderWidth: 0 }] }, options: { plugins: { legend: { display: false } } } });
      document.getElementById('bullPct').textContent = `${bull}%`;
      document.getElementById('bearPct').textContent = `${bear}%`;
    }

    function fillKpis(quote) {
      document.getElementById('kpiPrice').textContent = formatCurrency(quote.price, quote.currency);
      const ch = quote.change; const chp = quote.changePercent;
      const sign = ch > 0 ? '+' : '';
      document.getElementById('kpiChange').innerHTML = `<span class="${ch >= 0 ? 'bull' : 'bear'}">${sign}${ch?.toFixed?.(2) ?? ch} (${sign}${chp?.toFixed?.(2) ?? chp}%)</span>`;
      document.getElementById('kpiVolume').textContent = formatNumber(quote.volume);
      document.getElementById('kpiMcap').textContent = formatMcap(quote.marketCap);
      document.getElementById('kpiPE').textContent = quote.pe?.toFixed ? quote.pe.toFixed(1) : (quote.pe ?? '-');
      document.getElementById('kpiPrev').textContent = formatCurrency(quote.previousClose, quote.currency);
      document.getElementById('kpiHigh').textContent = formatCurrency(quote.dayHigh, quote.currency);
      document.getElementById('kpiLow').textContent = formatCurrency(quote.dayLow, quote.currency);
    }

    async function fetchAllProviders(symbol) {
      const providers = ['finnhub', 'polygon', 'iex', 'alpha_vantage', 'twelve_data', 'yahoo'];
      const results = {};
      
      for (const provider of providers) {
        try {
          const res = await fetch(`/api/quote?symbol=${encodeURIComponent(symbol)}&provider=${provider}`);
          if (res.ok) {
            const data = await res.json();
            results[provider] = {
              price: data.price,
              change: data.change,
              timestamp: data.lastUpdate || new Date().toISOString(),
              quality: data.dataQuality || 'unknown'
            };
          }
        } catch (e) {
          results[provider] = { error: e.message };
        }
      }
      return results;
    }

    async function testAllProviders(symbol) {
      const comp = document.getElementById('dataComparison');
      comp.innerHTML = '<div>Testing all providers...</div>';
      
      try {
        const results = await fetchAllProviders(symbol);
        let html = '<div style="margin-bottom:10px;"><strong>Provider Comparison:</strong></div>';
        
        for (const [provider, data] of Object.entries(results)) {
          if (data.error) {
            html += `<div style="margin-bottom:5px; color:#999;">${provider.toUpperCase()}: <span style="color:#e74c3c;">Failed</span></div>`;
          } else {
            const time = new Date(data.timestamp).toLocaleTimeString();
            const quality = data.quality === 'real-time' ? '🟢' : data.quality === 'delayed' ? '🟡' : '⚪';
            html += `<div style="margin-bottom:5px;">${provider.toUpperCase()}: <strong>$${data.price?.toFixed(2)}</strong> ${quality} (${time})</div>`;
          }
        }
        
        html += `
          <div style="margin-top:10px; font-size:11px; color:#999; border-top:1px solid #eee; padding-top:8px;">
            <div><strong>Why prices differ:</strong></div>
            <div>• Different data sources have different update frequencies</div>
            <div>• Some show pre-market, others regular market</div>
            <div>• Real-time vs delayed data (15-20 min delay)</div>
            <div>• Different consolidation rules</div>
            <div>• Google may use a different primary source</div>
          </div>
        `;
        
        comp.innerHTML = html;
      } catch (e) {
        comp.innerHTML = `<div style="color:#e74c3c;">Error testing providers: ${e.message}</div>`;
      }
    }

    async function loadAlphaVantageData(symbol) {
      const alphaData = document.getElementById('alphaVantageData');
      const loadBtn = document.getElementById('loadAlphaVantageBtn');
      
      loadBtn.textContent = 'Loading...';
      loadBtn.disabled = true;
      alphaData.style.display = 'block';
      
      try {
        // Load technical indicators
        const indicators = ['RSI', 'MACD', 'BBANDS', 'SMA', 'EMA', 'STOCH'];
        const indicatorPromises = indicators.map(async (indicator) => {
          try {
            const res = await fetch(`/api/alpha-vantage/technical/${indicator}?symbol=${encodeURIComponent(symbol)}&time_period=20`);
            if (res.ok) {
              const data = await res.json();
              const latest = Object.keys(data)[0];
              return { indicator, value: data[latest], date: latest };
            }
          } catch (e) {
            console.log(`Failed to load ${indicator}:`, e.message);
          }
          return null;
        });
        
        const indicatorResults = await Promise.all(indicatorPromises);
        const validIndicators = indicatorResults.filter(r => r !== null);
        
        // Display technical indicators
        const indicatorsGrid = document.getElementById('indicatorsGrid');
        indicatorsGrid.innerHTML = '';
        
        validIndicators.forEach(ind => {
          const div = document.createElement('div');
          div.className = 'info';
          div.innerHTML = `
            <div class="label">${ind.indicator}</div>
            <div class="value">${formatIndicatorValue(ind.indicator, ind.value)}</div>
          `;
          indicatorsGrid.appendChild(div);
        });
        
        // Load company overview
        try {
          const overviewRes = await fetch(`/api/alpha-vantage/overview?symbol=${encodeURIComponent(symbol)}`);
          if (overviewRes.ok) {
            const overview = await overviewRes.json();
            displayCompanyOverview(overview);
          }
        } catch (e) {
          console.log('Failed to load company overview:', e.message);
        }
        
        loadBtn.textContent = 'Refresh Alpha Vantage Data';
        loadBtn.disabled = false;
        
      } catch (e) {
        loadBtn.textContent = 'Load Alpha Vantage Data';
        loadBtn.disabled = false;
        console.error('Error loading Alpha Vantage data:', e);
      }
    }

    function formatIndicatorValue(indicator, value) {
      if (!value) return '-';
      
      switch(indicator) {
        case 'RSI':
          const rsi = parseFloat(value.RSI);
          return rsi ? `${rsi.toFixed(1)} ${rsi > 70 ? '🔴' : rsi < 30 ? '🟢' : '🟡'}` : '-';
        case 'MACD':
          const macd = parseFloat(value.MACD);
          const signal = parseFloat(value.MACD_Signal);
          return macd ? `${macd.toFixed(3)} / ${signal.toFixed(3)}` : '-';
        case 'BBANDS':
          const upper = parseFloat(value.Real_Upper_Band);
          const middle = parseFloat(value.Real_Middle_Band);
          const lower = parseFloat(value.Real_Lower_Band);
          return upper ? `${upper.toFixed(2)} / ${middle.toFixed(2)} / ${lower.toFixed(2)}` : '-';
        case 'SMA':
        case 'EMA':
          const sma = parseFloat(value.SMA || value.EMA);
          return sma ? sma.toFixed(2) : '-';
        case 'STOCH':
          const k = parseFloat(value.SlowK);
          const d = parseFloat(value.SlowD);
          return k ? `${k.toFixed(1)} / ${d.toFixed(1)}` : '-';
        default:
          return JSON.stringify(value).substring(0, 20) + '...';
      }
    }

    function displayCompanyOverview(overview) {
      const overviewGrid = document.getElementById('overviewGrid');
      overviewGrid.innerHTML = '';
      
      const overviewData = [
        { label: 'Sector', value: overview.sector || '-' },
        { label: 'Industry', value: overview.industry || '-' },
        { label: 'Market Cap', value: formatMcap(overview.marketCap) },
        { label: 'P/E Ratio', value: overview.pe ? overview.pe.toFixed(2) : '-' },
        { label: 'PEG Ratio', value: overview.peg ? overview.peg.toFixed(2) : '-' },
        { label: 'EPS', value: overview.eps ? overview.eps.toFixed(2) : '-' },
        { label: 'Dividend Yield', value: overview.dividendYield ? `${(overview.dividendYield * 100).toFixed(2)}%` : '-' },
        { label: 'Beta', value: overview.beta ? overview.beta.toFixed(2) : '-' },
        { label: '52W High', value: formatCurrency(overview.high52Week) },
        { label: '52W Low', value: formatCurrency(overview.low52Week) },
        { label: '50D MA', value: formatCurrency(overview.movingAverage50) },
        { label: '200D MA', value: formatCurrency(overview.movingAverage200) },
        { label: 'Target Price', value: formatCurrency(overview.analystTargetPrice) },
        { label: 'Rating', value: overview.analystRating || '-' }
      ];
      
      overviewData.forEach(item => {
        const div = document.createElement('div');
        div.className = 'info';
        div.innerHTML = `
          <div class="label">${item.label}</div>
          <div class="value">${item.value}</div>
        `;
        overviewGrid.appendChild(div);
      });
    }

    function updateDataComparison(symbol, currentQuote) {
      const comp = document.getElementById('dataComparison');
      comp.innerHTML = `
        <div style="margin-bottom:8px;"><strong>Current: ${currentQuote.provider?.toUpperCase() || 'UNKNOWN'}</strong></div>
        <div style="margin-bottom:8px;">Price: <strong>$${currentQuote.price?.toFixed(2)}</strong></div>
        <div style="margin-bottom:8px;">Time: ${new Date(currentQuote.lastUpdate || Date.now()).toLocaleTimeString()}</div>
        <div style="margin-bottom:8px;">Quality: ${currentQuote.dataQuality || 'unknown'}</div>
        <div style="margin-bottom:8px;">Session: ${currentQuote.session || 'REGULAR'}</div>
        <div style="font-size:11px; color:#999;">
          <div>Why prices differ:</div>
          <div>• Different data sources</div>
          <div>• Different timestamps</div>
          <div>• Pre/post market vs regular</div>
          <div>• Real-time vs delayed</div>
        </div>
      `;
    }

    function fillInfo(quote) {
      const info = document.getElementById('stockInfo');
      const source = (quote.provider || '').toUpperCase();
      const asOf = quote.asOfISO ? new Date(quote.asOfISO) : new Date();
      const delayedBadge = quote.isDelayed ? ' (Delayed)' : '';
      const session = quote.session || 'REGULAR';
      const dataQuality = quote.dataQuality || 'unknown';
      const qualityBadge = dataQuality === 'real-time' ? ' 🟢' : dataQuality === 'delayed' ? ' 🟡' : ' ⚪';
      info.innerHTML = `
        <div class="info"><div class="label">Symbol</div><div class="value">${quote.symbol} (${quote.exchangeName})</div></div>
        <div class="info"><div class="label">Company</div><div class="value">${quote.name}</div></div>
        <div class="info"><div class="label">Currency</div><div class="value">${quote.currency || 'USD'}</div></div>
        <div class="info"><div class="label">Session</div><div class="value">${session}</div></div>
        <div class="info"><div class="label">Data Source</div><div class="value">${source || 'YAHOO'}${delayedBadge}${qualityBadge}</div></div>
        <div class="info"><div class="label">As of</div><div class="value">${asOf.toLocaleString()}</div></div>
      `;
      
      // Update comparison
      updateDataComparison(quote.symbol, quote);
    }

    function populateInitialDatalist() {
      const dl = document.getElementById('stockSuggestions');
      if (!dl) return;
      dl.innerHTML = '';
      // Put NASDAQ first
      const ordered = [...localCompanies.filter(c => c.e === 'NASDAQ'), ...localCompanies.filter(c => c.e !== 'NASDAQ')];
      ordered.slice(0, 50).forEach(c => {
        const opt = document.createElement('option');
        opt.value = c.s;
        opt.label = `${c.n} (${c.e})`;
        dl.appendChild(opt);
      });
    }

    function findLocalByQuery(query) {
      const q = query.trim();
      if (!q) return null;
      const sym = q.toUpperCase();
      const exact = localCompanies.find(c => c.s === sym);
      if (exact) return exact;
      const nameMatch = localCompanies.find(c => c.n.toLowerCase().includes(q.toLowerCase()));
      return nameMatch || null;
    }

    async function analyze(symbolOrName) {
      const query = (symbolOrName || document.getElementById('stockInput').value).trim();
      if (!query) { alert('Enter a symbol or company name'); return; }

      // Prefer local resolution first
      let resolved = findLocalByQuery(query);
      let symbol = resolved?.s || query.toUpperCase();
      let exchangeName = resolved?.e || null;
      let nameOverride = resolved?.n || null;

      // If still not clearly a symbol, use API search
      if (!/^[A-Z.]{1,6}$/.test(symbol)) {
        try {
          const results = await resolveSymbolFromApi(query);
          if (results.length) {
            const preferred = results.find(q => q.exchDisp === 'NASDAQ' || q.exchange === 'NMS') || results[0];
            symbol = preferred.symbol.toUpperCase();
            exchangeName = preferred.exchDisp || preferred.exchange || exchangeName;
            nameOverride = preferred.longname || preferred.shortname || nameOverride;
          }
        } catch {}
      }

      currentSymbol = symbol;
      currentExchange = exchangeName;

      document.getElementById('histTitle').textContent = `Historical Price (${document.querySelector('.tf.active').textContent})`;

      const [quote, history] = await Promise.all([
        safeFetchLiveQuote(symbol),
        safeFetchStockHistory(symbol, selectedRange)
      ]);

      if (nameOverride) quote.name = nameOverride;
      if (exchangeName && quote.exchangeName === '—') quote.exchangeName = exchangeName;

      fillKpis(quote);
      fillInfo(quote);

      drawPriceChart(history);

      // Try ML service first
      let pred, data;
      try {
        const closes = history.map(d => d.price);
        const mlRes = await fetch('/api/ml/predict', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ symbol, days: selectedPredictionDays, closes }) });
        if (mlRes.ok) {
          const ml = await mlRes.json();
          const start = new Date();
          data = Array.from({ length: Math.min(selectedPredictionDays, ml.predictions?.length || 0) }, (_, i) => ({ date: new Date(start.getTime() + (i+1)*86400000), price: ml.predictions[i] }));
          // Fallback if ML predictions empty
          if (!data.length) ({ pred, data } = generatePredictionPath(quote, history));
          else {
            const direction = (data[data.length-1].price >= quote.price) ? 'bullish' : 'bearish';
            pred = { direction, confidence: 70, bullishRatio: direction==='bullish'?0.6:0.4 };
          }
        } else {
          ({ pred, data } = generatePredictionPath(quote, history));
        }
      } catch { ({ pred, data } = generatePredictionPath(quote, history)); }
      drawPredictionChart(data, pred);
      updateMoodChart(pred);

      document.getElementById('predictionText').innerHTML = `${pred.direction === 'bullish' ? '<span class="bull">Bullish</span>' : '<span class="bear">Bearish</span>'} outlook next 30 days • Confidence ${pred.confidence}%`;
      document.getElementById('results').style.display = 'block';
      document.getElementById('alphaVantageData').style.display = 'block';

      startLiveUpdates();
    }

    function startLiveUpdates() {
      if (liveTimer) { clearInterval(liveTimer); liveTimer = null; }
      if (!currentSymbol) return;
      liveTimer = setInterval(async () => {
        try {
          const q = await safeFetchLiveQuote(currentSymbol);
          fillKpis(q);
        } catch {}
      }, 30000);
    }

    // Events
    document.getElementById('analyzeBtn').addEventListener('click', () => analyze());
    document.getElementById('stockInput').addEventListener('input', debounce(updateSuggestions, 250));
    document.getElementById('stockInput').addEventListener('keypress', (e) => { if (e.key === 'Enter') analyze(); });
    document.getElementById('testProvidersBtn').addEventListener('click', () => {
      if (currentSymbol) testAllProviders(currentSymbol);
      else alert('Please analyze a stock first');
    });
    document.getElementById('loadAlphaVantageBtn').addEventListener('click', () => {
      if (currentSymbol) loadAlphaVantageData(currentSymbol);
      else alert('Please analyze a stock first');
    });
    // Historical timeframe buttons
    document.querySelectorAll('.primary .tf').forEach(btn => btn.addEventListener('click', async (e) => {
      document.querySelectorAll('.primary .tf').forEach(b => b.classList.remove('active'));
      e.currentTarget.classList.add('active');
      selectedRange = e.currentTarget.getAttribute('data-range');
      selectedDays = Number(e.currentTarget.getAttribute('data-days'));
      if (currentSymbol) {
        try {
          document.getElementById('histTitle').textContent = `Historical Price (${e.currentTarget.textContent})`;
          const history = await safeFetchStockHistory(currentSymbol, selectedRange);
          drawPriceChart(history);
          const q = await safeFetchLiveQuote(currentSymbol);
          const { pred, data } = generatePredictionPath(q, history);
          drawPredictionChart(data, pred);
        } catch {}
      }
    }));

    // Prediction timeframe buttons
    document.querySelectorAll('.chart-card .tf').forEach(btn => btn.addEventListener('click', async (e) => {
      document.querySelectorAll('.chart-card .tf').forEach(b => b.classList.remove('active'));
      e.currentTarget.classList.add('active');
      selectedPredictionDays = Number(e.currentTarget.getAttribute('data-days'));
      if (currentSymbol) {
        try {
          const history = await safeFetchStockHistory(currentSymbol, selectedRange);
          const q = await safeFetchLiveQuote(currentSymbol);
          const { pred, data } = generatePredictionPath(q, history, selectedPredictionDays);
          drawPredictionChart(data, pred);
        } catch {}
      }
    }));

    function debounce(fn, wait) { let t; return (...args) => { clearTimeout(t); t = setTimeout(() => fn.apply(null, args), wait); }; }

    // Initialize datalist on load
    window.addEventListener('DOMContentLoaded', populateInitialDatalist);
    </script>
</body>
</html>
